import "./style.css"; // For webpack support

import {
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Scene,
  Color,
  Fog,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  TextureLoader,
  MeshLambertMaterial,
  DoubleSide,
  ParametricBufferGeometry,
  Mesh,
  SphereGeometry,
  MeshLambertMaterial,
  Mesh,
  RepeatWrapping,
  sRGBEncoding,
  MeshLambertMaterial,
  Mesh,
  PlaneGeometry,
  BoxGeometry,
  MeshLambertMaterial,
  Mesh,
  Mesh,
  Mesh,
  BoxGeometry,
  BoxGeometry,
  Mesh,
  Mesh,
  WebGLRenderer,
  sRGBEncoding,
  PerspectiveCamera,
  Scene,
  AmbientLight,
  SpotLight,
  DirectionalLight,
  Plane,
  Vector3,
  Plane,
  Vector3,
  MeshPhongMaterial,
  DoubleSide,
  TorusKnotGeometry,
  Mesh,
  Mesh,
  PlaneGeometry,
  MeshPhongMaterial,
  WebGLRenderer,
  Plane,
  Plane,
  Vector3,
  Vector3,
  Vector3,
  Matrix4,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  PerspectiveCamera,
  Scene,
  AmbientLight,
  SpotLight,
  DirectionalLight,
  MeshPhongMaterial,
  DoubleSide,
  Group,
  BoxGeometry,
  Mesh,
  PlaneGeometry,
  Color,
  Group,
  MeshBasicMaterial,
  DoubleSide,
  Mesh,
  Mesh,
  MeshPhongMaterial,
  WebGLRenderer,
  Matrix4,
  Matrix4,
  Plane,
  Vector3,
  Plane,
  Vector3,
  Plane,
  Vector3,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  HemisphereLight,
  CameraHelper,
  Group,
  SphereGeometry,
  MeshLambertMaterial,
  Color,
  DoubleSide,
  Mesh,
  Group,
  PlaneHelper,
  PlaneHelper,
  PlaneHelper,
  Group,
  MeshBasicMaterial,
  AlwaysStencilFunc,
  BackSide,
  IncrementWrapStencilOp,
  IncrementWrapStencilOp,
  IncrementWrapStencilOp,
  Mesh,
  FrontSide,
  DecrementWrapStencilOp,
  DecrementWrapStencilOp,
  DecrementWrapStencilOp,
  Mesh,
  Clock,
  Scene,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  Plane,
  Vector3,
  Plane,
  Vector3,
  Plane,
  Vector3,
  PlaneHelper,
  TorusKnotGeometry,
  Group,
  PlaneGeometry,
  Group,
  MeshStandardMaterial,
  NotEqualStencilFunc,
  ReplaceStencilOp,
  ReplaceStencilOp,
  ReplaceStencilOp,
  Mesh,
  MeshStandardMaterial,
  DoubleSide,
  Mesh,
  Mesh,
  PlaneGeometry,
  ShadowMaterial,
  DoubleSide,
  WebGLRenderer,
  Vector3,
  Vector3,
  Vector2,
  TextureLoader,
  MeshPhongMaterial,
  Vector2,
  Vector3,
  Euler,
  Vector3,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  DirectionalLight,
  BufferGeometry,
  Vector3,
  Vector3,
  Line,
  LineBasicMaterial,
  Raycaster,
  Mesh,
  BoxGeometry,
  MeshNormalMaterial,
  MeshPhongMaterial,
  Mesh,
  DepthFormat,
  UnsignedShortType,
  DepthFormat,
  DepthStencilFormat,
  UnsignedShortType,
  UnsignedIntType,
  UnsignedInt248Type,
  WebGLRenderer,
  PerspectiveCamera,
  WebGLRenderTarget,
  RGBFormat,
  NearestFilter,
  NearestFilter,
  DepthStencilFormat,
  DepthTexture,
  OrthographicCamera,
  ShaderMaterial,
  PlaneGeometry,
  Mesh,
  Scene,
  Scene,
  TorusKnotGeometry,
  MeshBasicMaterial,
  Mesh,
  Vector2,
  Color,
  PerspectiveCamera,
  OrthographicCamera,
  Scene,
  Scene,
  BufferGeometry,
  Float32BufferAttribute,
  BufferAttribute,
  DynamicDrawUsage,
  LineBasicMaterial,
  Line,
  DataTexture,
  RGBFormat,
  NearestFilter,
  NearestFilter,
  SpriteMaterial,
  Sprite,
  WebGLRenderer,
  Scene,
  Color,
  Scene,
  PerspectiveCamera,
  OrthographicCamera,
  Sprite,
  SpriteMaterial,
  CanvasTexture,
  Mesh,
  MeshLambertMaterial,
  DoubleSide,
  PointLight,
  WebGLRenderer,
  BufferGeometryLoader,
  Float32BufferAttribute,
  PerspectiveCamera,
  Scene,
  Color,
  AmbientLight,
  DirectionalLight,
  Group,
  Vector4,
  MathUtils,
  BufferGeometry,
  LineBasicMaterial,
  Line,
  BufferGeometry,
  LineBasicMaterial,
  Line,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  TextureLoader,
  RepeatWrapping,
  ParametricBufferGeometry,
  MeshLambertMaterial,
  DoubleSide,
  Mesh,
  WebGLRenderer,
  Vector3,
  Raycaster,
  Vector2,
  Vector2,
  Vector2,
  BoxGeometry,
  Scene,
  Color,
  PerspectiveCamera,
  AmbientLight,
  SpotLight,
  PlaneGeometry,
  ShadowMaterial,
  Mesh,
  GridHelper,
  WebGLRenderer,
  BufferGeometry,
  BufferAttribute,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  MeshLambertMaterial,
  Mesh,
  Vector3,
  Clock,
  PerspectiveCamera,
  Scene,
  Color,
  FogExp2,
  PlaneGeometry,
  CanvasTexture,
  ClampToEdgeWrapping,
  ClampToEdgeWrapping,
  Mesh,
  MeshBasicMaterial,
  WebGLRenderer,
  Vector3,
  Vector3,
  Cache,
  PerspectiveCamera,
  Vector3,
  Scene,
  Color,
  Fog,
  DirectionalLight,
  PointLight,
  MeshPhongMaterial,
  MeshPhongMaterial,
  Group,
  Mesh,
  PlaneGeometry,
  MeshBasicMaterial,
  WebGLRenderer,
  FontLoader,
  TextGeometry,
  Mesh,
  Mesh,
  PerspectiveCamera,
  Scene,
  Color,
  FontLoader,
  LineBasicMaterial,
  DoubleSide,
  MeshBasicMaterial,
  DoubleSide,
  ShapeGeometry,
  Mesh,
  Object3D,
  BufferGeometry,
  Line,
  WebGLRenderer,
  PerspectiveCamera,
  Scene,
  Color,
  FontLoader,
  Color,
  MeshBasicMaterial,
  DoubleSide,
  MeshBasicMaterial,
  DoubleSide,
  ShapeGeometry,
  Mesh,
  Group,
  Mesh,
  WebGLRenderer,
  WebGLRenderer,
  PerspectiveCamera,
  Scene,
  PointLight,
  PointLightHelper,
  GridHelper,
  PolarGridHelper,
  Group,
  BoxHelper,
  WireframeGeometry,
  LineSegments,
  BoxHelper,
  EdgesGeometry,
  LineSegments,
  BoxHelper,
  BoxHelper,
  BoxHelper,
  Vector3,
  Euler,
  Quaternion,
  Vector3,
  BufferGeometryLoader,
  MeshNormalMaterial,
  Matrix4,
  InstancedMesh,
  Matrix4,
  Mesh,
  Matrix4,
  Mesh,
  PerspectiveCamera,
  WebGLRenderer,
  sRGBEncoding,
  Scene,
  Color,
} from "three";

import Stats from "three/examples/jsm/libs/stats.module.js";
import { GUI } from "three/examples/jsm/libs/dat.gui.module.js";

import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import * as BufferGeometryUtils from "three/examples/jsm/utils/BufferGeometryUtils.js";

let container, stats, gui, guiStatsEl;
let camera, controls, scene, renderer, material;

// gui

const Method = {
  INSTANCED: "INSTANCED",
  MERGED: "MERGED",
  NAIVE: "NAIVE",
};

const api = {
  method: Method.INSTANCED,
  count: 1000,
};

//

init();
initMesh();
animate();

//

function clean() {
  const meshes = [];

  scene.traverse(function (object) {
    if (object.isMesh) meshes.push(object);
  });

  for (let i = 0; i < meshes.length; i++) {
    const mesh = meshes[i];
    mesh.material.dispose();
    mesh.geometry.dispose();

    scene.remove(mesh);
  }
}

const randomizeMatrix = (function () {
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3();

  return function (matrix) {
    position.x = Math.random() * 40 - 20;
    position.y = Math.random() * 40 - 20;
    position.z = Math.random() * 40 - 20;

    rotation.x = Math.random() * 2 * Math.PI;
    rotation.y = Math.random() * 2 * Math.PI;
    rotation.z = Math.random() * 2 * Math.PI;

    quaternion.setFromEuler(rotation);

    scale.x = scale.y = scale.z = Math.random() * 1;

    matrix.compose(position, quaternion, scale);
  };
})();

function initMesh() {
  clean();

  // make instances
  new BufferGeometryLoader()
    .setPath("models/json/")
    .load("suzanne_buffergeometry.json", function (geometry) {
      material = new MeshNormalMaterial();

      geometry.computeVertexNormals();

      console.time(api.method + " (build)");

      switch (api.method) {
        case Method.INSTANCED:
          makeInstanced(geometry);
          break;

        case Method.MERGED:
          makeMerged(geometry);
          break;

        case Method.NAIVE:
          makeNaive(geometry);
          break;
      }

      console.timeEnd(api.method + " (build)");
    });
}

function makeInstanced(geometry) {
  const matrix = new Matrix4();
  const mesh = new InstancedMesh(geometry, material, api.count);

  for (let i = 0; i < api.count; i++) {
    randomizeMatrix(matrix);
    mesh.setMatrixAt(i, matrix);
  }

  scene.add(mesh);

  //

  const geometryByteLength = getGeometryByteLength(geometry);

  guiStatsEl.innerHTML = [
    "<i>GPU draw calls</i>: 1",
    "<i>GPU memory</i>: " + formatBytes(api.count * 16 + geometryByteLength, 2),
  ].join("<br/>");
}

function makeMerged(geometry) {
  const geometries = [];
  const matrix = new Matrix4();

  for (let i = 0; i < api.count; i++) {
    randomizeMatrix(matrix);

    const instanceGeometry = geometry.clone();
    instanceGeometry.applyMatrix4(matrix);

    geometries.push(instanceGeometry);
  }

  const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);

  scene.add(new Mesh(mergedGeometry, material));

  //

  guiStatsEl.innerHTML = [
    "<i>GPU draw calls</i>: 1",
    "<i>GPU memory</i>: " +
      formatBytes(getGeometryByteLength(mergedGeometry), 2),
  ].join("<br/>");
}

function makeNaive(geometry) {
  const matrix = new Matrix4();

  for (let i = 0; i < api.count; i++) {
    randomizeMatrix(matrix);

    const mesh = new Mesh(geometry, material);
    mesh.applyMatrix4(matrix);

    scene.add(mesh);
  }

  //

  const geometryByteLength = getGeometryByteLength(geometry);

  guiStatsEl.innerHTML = [
    "<i>GPU draw calls</i>: " + api.count,
    "<i>GPU memory</i>: " + formatBytes(api.count * 16 + geometryByteLength, 2),
  ].join("<br/>");
}

function init() {
  const width = window.innerWidth;
  const height = window.innerHeight;

  // camera

  camera = new PerspectiveCamera(70, width / height, 1, 100);
  camera.position.z = 30;

  // renderer

  renderer = new WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(width, height);
  renderer.outputEncoding = sRGBEncoding;

  container = document.getElementById("container");
  container.appendChild(renderer.domElement);

  // scene

  scene = new Scene();
  scene.background = new Color(0xffffff);

  // controls

  controls = new OrbitControls(camera, renderer.domElement);
  controls.autoRotate = true;

  // stats

  stats = new Stats();
  container.appendChild(stats.dom);

  // gui

  gui = new GUI();
  gui.add(api, "method", Method).onChange(initMesh);
  gui.add(api, "count", 1, 10000).step(1).onChange(initMesh);

  const perfFolder = gui.addFolder("Performance");

  guiStatsEl = document.createElement("li");
  guiStatsEl.classList.add("gui-stats");

  perfFolder.__ul.appendChild(guiStatsEl);
  perfFolder.open();

  // listeners

  window.addEventListener("resize", onWindowResize);

  Object.assign(window, { scene });
}

//

function onWindowResize() {
  const width = window.innerWidth;
  const height = window.innerHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();

  renderer.setSize(width, height);
}

function animate() {
  requestAnimationFrame(animate);

  controls.update();
  stats.update();

  render();
}

function render() {
  renderer.render(scene, camera);
}

//

function getGeometryByteLength(geometry) {
  let total = 0;

  if (geometry.index) total += geometry.index.array.byteLength;

  for (const name in geometry.attributes) {
    total += geometry.attributes[name].array.byteLength;
  }

  return total;
}

// Source: https://stackoverflow.com/a/18650828/1314762
function formatBytes(bytes, decimals) {
  if (bytes === 0) return "0 bytes";

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["bytes", "KB", "MB"];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
}
