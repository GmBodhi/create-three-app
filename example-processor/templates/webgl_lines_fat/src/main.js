import "./style.css"; // For webpack support

import {
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Scene,
  Color,
  Fog,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  TextureLoader,
  MeshLambertMaterial,
  DoubleSide,
  ParametricBufferGeometry,
  Mesh,
  SphereGeometry,
  MeshLambertMaterial,
  Mesh,
  RepeatWrapping,
  sRGBEncoding,
  MeshLambertMaterial,
  Mesh,
  PlaneGeometry,
  BoxGeometry,
  MeshLambertMaterial,
  Mesh,
  Mesh,
  Mesh,
  BoxGeometry,
  BoxGeometry,
  Mesh,
  Mesh,
  WebGLRenderer,
  sRGBEncoding,
  PerspectiveCamera,
  Scene,
  AmbientLight,
  SpotLight,
  DirectionalLight,
  Plane,
  Vector3,
  Plane,
  Vector3,
  MeshPhongMaterial,
  DoubleSide,
  TorusKnotGeometry,
  Mesh,
  Mesh,
  PlaneGeometry,
  MeshPhongMaterial,
  WebGLRenderer,
  Plane,
  Plane,
  Vector3,
  Vector3,
  Vector3,
  Matrix4,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  PerspectiveCamera,
  Scene,
  AmbientLight,
  SpotLight,
  DirectionalLight,
  MeshPhongMaterial,
  DoubleSide,
  Group,
  BoxGeometry,
  Mesh,
  PlaneGeometry,
  Color,
  Group,
  MeshBasicMaterial,
  DoubleSide,
  Mesh,
  Mesh,
  MeshPhongMaterial,
  WebGLRenderer,
  Matrix4,
  Matrix4,
  Plane,
  Vector3,
  Plane,
  Vector3,
  Plane,
  Vector3,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  HemisphereLight,
  CameraHelper,
  Group,
  SphereGeometry,
  MeshLambertMaterial,
  Color,
  DoubleSide,
  Mesh,
  Group,
  PlaneHelper,
  PlaneHelper,
  PlaneHelper,
  Group,
  MeshBasicMaterial,
  AlwaysStencilFunc,
  BackSide,
  IncrementWrapStencilOp,
  IncrementWrapStencilOp,
  IncrementWrapStencilOp,
  Mesh,
  FrontSide,
  DecrementWrapStencilOp,
  DecrementWrapStencilOp,
  DecrementWrapStencilOp,
  Mesh,
  Clock,
  Scene,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  Plane,
  Vector3,
  Plane,
  Vector3,
  Plane,
  Vector3,
  PlaneHelper,
  TorusKnotGeometry,
  Group,
  PlaneGeometry,
  Group,
  MeshStandardMaterial,
  NotEqualStencilFunc,
  ReplaceStencilOp,
  ReplaceStencilOp,
  ReplaceStencilOp,
  Mesh,
  MeshStandardMaterial,
  DoubleSide,
  Mesh,
  Mesh,
  PlaneGeometry,
  ShadowMaterial,
  DoubleSide,
  WebGLRenderer,
  Vector3,
  Vector3,
  Vector2,
  TextureLoader,
  MeshPhongMaterial,
  Vector2,
  Vector3,
  Euler,
  Vector3,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  DirectionalLight,
  BufferGeometry,
  Vector3,
  Vector3,
  Line,
  LineBasicMaterial,
  Raycaster,
  Mesh,
  BoxGeometry,
  MeshNormalMaterial,
  MeshPhongMaterial,
  Mesh,
  DepthFormat,
  UnsignedShortType,
  DepthFormat,
  DepthStencilFormat,
  UnsignedShortType,
  UnsignedIntType,
  UnsignedInt248Type,
  WebGLRenderer,
  PerspectiveCamera,
  WebGLRenderTarget,
  RGBFormat,
  NearestFilter,
  NearestFilter,
  DepthStencilFormat,
  DepthTexture,
  OrthographicCamera,
  ShaderMaterial,
  PlaneGeometry,
  Mesh,
  Scene,
  Scene,
  TorusKnotGeometry,
  MeshBasicMaterial,
  Mesh,
  Vector2,
  Color,
  PerspectiveCamera,
  OrthographicCamera,
  Scene,
  Scene,
  BufferGeometry,
  Float32BufferAttribute,
  BufferAttribute,
  DynamicDrawUsage,
  LineBasicMaterial,
  Line,
  DataTexture,
  RGBFormat,
  NearestFilter,
  NearestFilter,
  SpriteMaterial,
  Sprite,
  WebGLRenderer,
  Scene,
  Color,
  Scene,
  PerspectiveCamera,
  OrthographicCamera,
  Sprite,
  SpriteMaterial,
  CanvasTexture,
  Mesh,
  MeshLambertMaterial,
  DoubleSide,
  PointLight,
  WebGLRenderer,
  BufferGeometryLoader,
  Float32BufferAttribute,
  PerspectiveCamera,
  Scene,
  Color,
  AmbientLight,
  DirectionalLight,
  Group,
  Vector4,
  MathUtils,
  BufferGeometry,
  LineBasicMaterial,
  Line,
  BufferGeometry,
  LineBasicMaterial,
  Line,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  TextureLoader,
  RepeatWrapping,
  ParametricBufferGeometry,
  MeshLambertMaterial,
  DoubleSide,
  Mesh,
  WebGLRenderer,
  Vector3,
  Raycaster,
  Vector2,
  Vector2,
  Vector2,
  BoxGeometry,
  Scene,
  Color,
  PerspectiveCamera,
  AmbientLight,
  SpotLight,
  PlaneGeometry,
  ShadowMaterial,
  Mesh,
  GridHelper,
  WebGLRenderer,
  BufferGeometry,
  BufferAttribute,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  MeshLambertMaterial,
  Mesh,
  Vector3,
  Clock,
  PerspectiveCamera,
  Scene,
  Color,
  FogExp2,
  PlaneGeometry,
  CanvasTexture,
  ClampToEdgeWrapping,
  ClampToEdgeWrapping,
  Mesh,
  MeshBasicMaterial,
  WebGLRenderer,
  Vector3,
  Vector3,
  Cache,
  PerspectiveCamera,
  Vector3,
  Scene,
  Color,
  Fog,
  DirectionalLight,
  PointLight,
  MeshPhongMaterial,
  MeshPhongMaterial,
  Group,
  Mesh,
  PlaneGeometry,
  MeshBasicMaterial,
  WebGLRenderer,
  FontLoader,
  TextGeometry,
  Mesh,
  Mesh,
  PerspectiveCamera,
  Scene,
  Color,
  FontLoader,
  LineBasicMaterial,
  DoubleSide,
  MeshBasicMaterial,
  DoubleSide,
  ShapeGeometry,
  Mesh,
  Object3D,
  BufferGeometry,
  Line,
  WebGLRenderer,
  PerspectiveCamera,
  Scene,
  Color,
  FontLoader,
  Color,
  MeshBasicMaterial,
  DoubleSide,
  MeshBasicMaterial,
  DoubleSide,
  ShapeGeometry,
  Mesh,
  Group,
  Mesh,
  WebGLRenderer,
  WebGLRenderer,
  PerspectiveCamera,
  Scene,
  PointLight,
  PointLightHelper,
  GridHelper,
  PolarGridHelper,
  Group,
  BoxHelper,
  WireframeGeometry,
  LineSegments,
  BoxHelper,
  EdgesGeometry,
  LineSegments,
  BoxHelper,
  BoxHelper,
  BoxHelper,
  Vector3,
  Euler,
  Quaternion,
  Vector3,
  BufferGeometryLoader,
  MeshNormalMaterial,
  Matrix4,
  InstancedMesh,
  Matrix4,
  Mesh,
  Matrix4,
  Mesh,
  PerspectiveCamera,
  WebGLRenderer,
  sRGBEncoding,
  Scene,
  Color,
  PerspectiveCamera,
  Scene,
  Color,
  Fog,
  AmbientLight,
  DirectionalLight,
  DirectionalLight,
  BufferGeometry,
  Color,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  BufferAttribute,
  BufferAttribute,
  BufferAttribute,
  MeshPhongMaterial,
  DoubleSide,
  Mesh,
  Raycaster,
  Vector2,
  BufferGeometry,
  BufferAttribute,
  LineBasicMaterial,
  Line,
  WebGLRenderer,
  Vector2,
  PerspectiveCamera,
  Scene,
  Color,
  DirectionalLight,
  BoxGeometry,
  Mesh,
  MeshLambertMaterial,
  Raycaster,
  WebGLRenderer,
  MathUtils,
  MathUtils,
  MathUtils,
  Vector2,
  Vector3,
  PerspectiveCamera,
  Scene,
  Color,
  Scene,
  WebGLRenderTarget,
  AmbientLight,
  SpotLight,
  MeshBasicMaterial,
  MeshPhongMaterial,
  Float32BufferAttribute,
  Matrix4,
  Quaternion,
  Color,
  BoxGeometry,
  Vector3,
  Euler,
  Vector3,
  Mesh,
  Mesh,
  Mesh,
  BoxGeometry,
  MeshLambertMaterial,
  WebGLRenderer,
  Vector2,
  OrthographicCamera,
  Scene,
  Color,
  DirectionalLight,
  BoxGeometry,
  Mesh,
  MeshLambertMaterial,
  Raycaster,
  WebGLRenderer,
  MathUtils,
  MathUtils,
  MathUtils,
  Vector2,
  PerspectiveCamera,
  Scene,
  Color,
  SphereGeometry,
  MeshBasicMaterial,
  Mesh,
  BufferGeometry,
  Vector3,
  Vector3,
  Float32BufferAttribute,
  Object3D,
  LineBasicMaterial,
  Line,
  LineSegments,
  Raycaster,
  WebGLRenderer,
  MathUtils,
  MathUtils,
  MathUtils,
  Scene,
  PerspectiveCamera,
  BoxGeometry,
  Color,
  BufferGeometry,
  Float32BufferAttribute,
  Float32BufferAttribute,
  ShaderMaterial,
  Color,
  TextureLoader,
  Points,
  WebGLRenderer,
  Raycaster,
  Vector2,
  Vector2,
  Matrix4,
  BufferGeometry,
  BufferAttribute,
  BufferAttribute,
  PointsMaterial,
  Points,
  BufferAttribute,
  PointsMaterial,
  Points,
  BufferAttribute,
  PointsMaterial,
  Points,
  Scene,
  Clock,
  PerspectiveCamera,
  Color,
  Color,
  Color,
  SphereGeometry,
  MeshBasicMaterial,
  Mesh,
  WebGLRenderer,
  Raycaster,
  PerspectiveCamera,
  Scene,
  Color,
  BoxGeometry,
  MeshBasicMaterial,
  Mesh,
  BoxGeometry,
  MeshLambertMaterial,
  TextureLoader,
  GridHelper,
  Raycaster,
  Vector2,
  PlaneGeometry,
  Mesh,
  MeshBasicMaterial,
  AmbientLight,
  DirectionalLight,
  WebGLRenderer,
  Mesh,
  PerspectiveCamera,
  Scene,
  Color,
  PointLight,
  BoxGeometry,
  Mesh,
  MeshLambertMaterial,
  WebGLRenderer,
  MathUtils,
  MathUtils,
  MathUtils,
  Clock,
  PerspectiveCamera,
  Scene,
  Color,
  Fog,
  HemisphereLight,
  HemisphereLightHelper,
  DirectionalLight,
  DirectionalLightHelper,
  PlaneGeometry,
  MeshLambertMaterial,
  Mesh,
  Color,
  Color,
  SphereGeometry,
  ShaderMaterial,
  BackSide,
  Mesh,
  AnimationMixer,
  WebGLRenderer,
  sRGBEncoding,
  Clock,
  PerspectiveCamera,
  Scene,
  SphereGeometry,
  PointLight,
  Mesh,
  MeshBasicMaterial,
  PointLight,
  Mesh,
  MeshBasicMaterial,
  PointLight,
  Mesh,
  MeshBasicMaterial,
  PointLight,
  Mesh,
  MeshBasicMaterial,
  WebGLRenderer,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  PerspectiveCamera,
  Color,
  Vector3,
  CatmullRomCurve3,
  Vector3,
  Color,
  Line,
  BufferGeometry,
  LineBasicMaterial,
  BufferGeometry,
  Float32BufferAttribute,
  Float32BufferAttribute,
  LineBasicMaterial,
  LineDashedMaterial,
  Line,
} from "three";

import Stats from "three/examples/jsm/libs/stats.module.js";
import { GPUStatsPanel } from "three/examples/jsm/utils/GPUStatsPanel.js";

import { GUI } from "three/examples/jsm/libs/dat.gui.module.js";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { Line2 } from "three/examples/jsm/lines/Line2.js";
import { LineMaterial } from "three/examples/jsm/lines/LineMaterial.js";
import { LineGeometry } from "three/examples/jsm/lines/LineGeometry.js";
import * as GeometryUtils from "three/examples/jsm/utils/GeometryUtils.js";

let line, renderer, scene, camera, camera2, controls;
let line1;
let matLine, matLineBasic, matLineDashed;
let stats, gpuPanel;
let gui;

// viewport
let insetWidth;
let insetHeight;

init();
animate();

function init() {
  renderer = new WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x000000, 0.0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene = new Scene();

  camera = new PerspectiveCamera(
    40,
    window.innerWidth / window.innerHeight,
    1,
    1000
  );
  camera.position.set(-40, 0, 60);

  camera2 = new PerspectiveCamera(40, 1, 1, 1000);
  camera2.position.copy(camera.position);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.minDistance = 10;
  controls.maxDistance = 500;

  // Position and Color Data

  const positions = [];
  const colors = [];

  const points = GeometryUtils.hilbert3D(
    new Vector3(0, 0, 0),
    20.0,
    1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7
  );

  const spline = new CatmullRomCurve3(points);
  const divisions = Math.round(12 * points.length);
  const point = new Vector3();
  const color = new Color();

  for (let i = 0, l = divisions; i < l; i++) {
    const t = i / l;

    spline.getPoint(t, point);
    positions.push(point.x, point.y, point.z);

    color.setHSL(t, 1.0, 0.5);
    colors.push(color.r, color.g, color.b);
  }

  // Line2 ( LineGeometry, LineMaterial )

  const geometry = new LineGeometry();
  geometry.setPositions(positions);
  geometry.setColors(colors);

  matLine = new LineMaterial({
    color: 0xffffff,
    linewidth: 5, // in world units with size attenuation, pixels otherwise
    vertexColors: true,

    //resolution:  // to be set by renderer, eventually
    dashed: false,
    alphaToCoverage: true,
  });

  line = new Line2(geometry, matLine);
  line.computeLineDistances();
  line.scale.set(1, 1, 1);
  scene.add(line);

  // Line ( BufferGeometry, LineBasicMaterial ) - rendered with gl.LINE_STRIP

  const geo = new BufferGeometry();
  geo.setAttribute("position", new Float32BufferAttribute(positions, 3));
  geo.setAttribute("color", new Float32BufferAttribute(colors, 3));

  matLineBasic = new LineBasicMaterial({ vertexColors: true });
  matLineDashed = new LineDashedMaterial({
    vertexColors: true,
    scale: 2,
    dashSize: 1,
    gapSize: 1,
  });

  line1 = new Line(geo, matLineBasic);
  line1.computeLineDistances();
  line1.visible = false;
  scene.add(line1);

  //

  window.addEventListener("resize", onWindowResize);
  onWindowResize();

  stats = new Stats();
  document.body.appendChild(stats.dom);

  gpuPanel = new GPUStatsPanel(renderer.getContext());
  stats.addPanel(gpuPanel);
  stats.showPanel(0);

  initGui();
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);

  insetWidth = window.innerHeight / 4; // square
  insetHeight = window.innerHeight / 4;

  camera2.aspect = insetWidth / insetHeight;
  camera2.updateProjectionMatrix();
}

function animate() {
  requestAnimationFrame(animate);

  stats.update();

  // main scene

  renderer.setClearColor(0x000000, 0);

  renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);

  // renderer will set this eventually
  matLine.resolution.set(window.innerWidth, window.innerHeight); // resolution of the viewport

  gpuPanel.startQuery();
  renderer.render(scene, camera);
  gpuPanel.endQuery();

  // inset scene

  renderer.setClearColor(0x222222, 1);

  renderer.clearDepth(); // important!

  renderer.setScissorTest(true);

  renderer.setScissor(20, 20, insetWidth, insetHeight);

  renderer.setViewport(20, 20, insetWidth, insetHeight);

  camera2.position.copy(camera.position);
  camera2.quaternion.copy(camera.quaternion);

  // renderer will set this eventually
  matLine.resolution.set(insetWidth, insetHeight); // resolution of the inset viewport

  renderer.render(scene, camera2);

  renderer.setScissorTest(false);
}

//

function initGui() {
  gui = new GUI();

  const param = {
    "line type": 0,
    "world units": false,
    width: 5,
    alphaToCoverage: true,
    dashed: false,
    "dash scale": 1,
    "dash / gap": 1,
  };

  gui
    .add(param, "line type", { LineGeometry: 0, "gl.LINE": 1 })
    .onChange(function (val) {
      switch (val) {
        case "0":
          line.visible = true;

          line1.visible = false;

          break;

        case "1":
          line.visible = false;

          line1.visible = true;

          break;
      }
    });

  gui.add(param, "world units").onChange(function (val) {
    matLine.worldUnits = val;
    matLine.needsUpdate = true;
  });

  gui.add(param, "width", 1, 10).onChange(function (val) {
    matLine.linewidth = val;
  });

  gui.add(param, "alphaToCoverage").onChange(function (val) {
    matLine.alphaToCoverage = val;
  });

  gui.add(param, "dashed").onChange(function (val) {
    matLine.dashed = val;
    line1.material = val ? matLineDashed : matLineBasic;
  });

  gui.add(param, "dash scale", 0.5, 2, 0.1).onChange(function (val) {
    matLine.dashScale = val;
    matLineDashed.scale = val;
  });

  gui
    .add(param, "dash / gap", { "2 : 1": 0, "1 : 1": 1, "1 : 2": 2 })
    .onChange(function (val) {
      switch (val) {
        case "0":
          matLine.dashSize = 2;
          matLine.gapSize = 1;

          matLineDashed.dashSize = 2;
          matLineDashed.gapSize = 1;

          break;

        case "1":
          matLine.dashSize = 1;
          matLine.gapSize = 1;

          matLineDashed.dashSize = 1;
          matLineDashed.gapSize = 1;

          break;

        case "2":
          matLine.dashSize = 1;
          matLine.gapSize = 2;

          matLineDashed.dashSize = 1;
          matLineDashed.gapSize = 2;

          break;
      }
    });
}
