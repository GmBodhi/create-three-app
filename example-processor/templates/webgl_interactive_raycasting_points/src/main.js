import "./style.css"; // For webpack support

import {
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Scene,
  Color,
  Fog,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  TextureLoader,
  MeshLambertMaterial,
  DoubleSide,
  ParametricBufferGeometry,
  Mesh,
  SphereGeometry,
  MeshLambertMaterial,
  Mesh,
  RepeatWrapping,
  sRGBEncoding,
  MeshLambertMaterial,
  Mesh,
  PlaneGeometry,
  BoxGeometry,
  MeshLambertMaterial,
  Mesh,
  Mesh,
  Mesh,
  BoxGeometry,
  BoxGeometry,
  Mesh,
  Mesh,
  WebGLRenderer,
  sRGBEncoding,
  PerspectiveCamera,
  Scene,
  AmbientLight,
  SpotLight,
  DirectionalLight,
  Plane,
  Vector3,
  Plane,
  Vector3,
  MeshPhongMaterial,
  DoubleSide,
  TorusKnotGeometry,
  Mesh,
  Mesh,
  PlaneGeometry,
  MeshPhongMaterial,
  WebGLRenderer,
  Plane,
  Plane,
  Vector3,
  Vector3,
  Vector3,
  Matrix4,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  PerspectiveCamera,
  Scene,
  AmbientLight,
  SpotLight,
  DirectionalLight,
  MeshPhongMaterial,
  DoubleSide,
  Group,
  BoxGeometry,
  Mesh,
  PlaneGeometry,
  Color,
  Group,
  MeshBasicMaterial,
  DoubleSide,
  Mesh,
  Mesh,
  MeshPhongMaterial,
  WebGLRenderer,
  Matrix4,
  Matrix4,
  Plane,
  Vector3,
  Plane,
  Vector3,
  Plane,
  Vector3,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  HemisphereLight,
  CameraHelper,
  Group,
  SphereGeometry,
  MeshLambertMaterial,
  Color,
  DoubleSide,
  Mesh,
  Group,
  PlaneHelper,
  PlaneHelper,
  PlaneHelper,
  Group,
  MeshBasicMaterial,
  AlwaysStencilFunc,
  BackSide,
  IncrementWrapStencilOp,
  IncrementWrapStencilOp,
  IncrementWrapStencilOp,
  Mesh,
  FrontSide,
  DecrementWrapStencilOp,
  DecrementWrapStencilOp,
  DecrementWrapStencilOp,
  Mesh,
  Clock,
  Scene,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  Plane,
  Vector3,
  Plane,
  Vector3,
  Plane,
  Vector3,
  PlaneHelper,
  TorusKnotGeometry,
  Group,
  PlaneGeometry,
  Group,
  MeshStandardMaterial,
  NotEqualStencilFunc,
  ReplaceStencilOp,
  ReplaceStencilOp,
  ReplaceStencilOp,
  Mesh,
  MeshStandardMaterial,
  DoubleSide,
  Mesh,
  Mesh,
  PlaneGeometry,
  ShadowMaterial,
  DoubleSide,
  WebGLRenderer,
  Vector3,
  Vector3,
  Vector2,
  TextureLoader,
  MeshPhongMaterial,
  Vector2,
  Vector3,
  Euler,
  Vector3,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  AmbientLight,
  DirectionalLight,
  DirectionalLight,
  BufferGeometry,
  Vector3,
  Vector3,
  Line,
  LineBasicMaterial,
  Raycaster,
  Mesh,
  BoxGeometry,
  MeshNormalMaterial,
  MeshPhongMaterial,
  Mesh,
  DepthFormat,
  UnsignedShortType,
  DepthFormat,
  DepthStencilFormat,
  UnsignedShortType,
  UnsignedIntType,
  UnsignedInt248Type,
  WebGLRenderer,
  PerspectiveCamera,
  WebGLRenderTarget,
  RGBFormat,
  NearestFilter,
  NearestFilter,
  DepthStencilFormat,
  DepthTexture,
  OrthographicCamera,
  ShaderMaterial,
  PlaneGeometry,
  Mesh,
  Scene,
  Scene,
  TorusKnotGeometry,
  MeshBasicMaterial,
  Mesh,
  Vector2,
  Color,
  PerspectiveCamera,
  OrthographicCamera,
  Scene,
  Scene,
  BufferGeometry,
  Float32BufferAttribute,
  BufferAttribute,
  DynamicDrawUsage,
  LineBasicMaterial,
  Line,
  DataTexture,
  RGBFormat,
  NearestFilter,
  NearestFilter,
  SpriteMaterial,
  Sprite,
  WebGLRenderer,
  Scene,
  Color,
  Scene,
  PerspectiveCamera,
  OrthographicCamera,
  Sprite,
  SpriteMaterial,
  CanvasTexture,
  Mesh,
  MeshLambertMaterial,
  DoubleSide,
  PointLight,
  WebGLRenderer,
  BufferGeometryLoader,
  Float32BufferAttribute,
  PerspectiveCamera,
  Scene,
  Color,
  AmbientLight,
  DirectionalLight,
  Group,
  Vector4,
  MathUtils,
  BufferGeometry,
  LineBasicMaterial,
  Line,
  BufferGeometry,
  LineBasicMaterial,
  Line,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  Vector4,
  TextureLoader,
  RepeatWrapping,
  ParametricBufferGeometry,
  MeshLambertMaterial,
  DoubleSide,
  Mesh,
  WebGLRenderer,
  Vector3,
  Raycaster,
  Vector2,
  Vector2,
  Vector2,
  BoxGeometry,
  Scene,
  Color,
  PerspectiveCamera,
  AmbientLight,
  SpotLight,
  PlaneGeometry,
  ShadowMaterial,
  Mesh,
  GridHelper,
  WebGLRenderer,
  BufferGeometry,
  BufferAttribute,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  CatmullRomCurve3,
  Line,
  LineBasicMaterial,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  MeshLambertMaterial,
  Mesh,
  Vector3,
  Clock,
  PerspectiveCamera,
  Scene,
  Color,
  FogExp2,
  PlaneGeometry,
  CanvasTexture,
  ClampToEdgeWrapping,
  ClampToEdgeWrapping,
  Mesh,
  MeshBasicMaterial,
  WebGLRenderer,
  Vector3,
  Vector3,
  Cache,
  PerspectiveCamera,
  Vector3,
  Scene,
  Color,
  Fog,
  DirectionalLight,
  PointLight,
  MeshPhongMaterial,
  MeshPhongMaterial,
  Group,
  Mesh,
  PlaneGeometry,
  MeshBasicMaterial,
  WebGLRenderer,
  FontLoader,
  TextGeometry,
  Mesh,
  Mesh,
  PerspectiveCamera,
  Scene,
  Color,
  FontLoader,
  LineBasicMaterial,
  DoubleSide,
  MeshBasicMaterial,
  DoubleSide,
  ShapeGeometry,
  Mesh,
  Object3D,
  BufferGeometry,
  Line,
  WebGLRenderer,
  PerspectiveCamera,
  Scene,
  Color,
  FontLoader,
  Color,
  MeshBasicMaterial,
  DoubleSide,
  MeshBasicMaterial,
  DoubleSide,
  ShapeGeometry,
  Mesh,
  Group,
  Mesh,
  WebGLRenderer,
  WebGLRenderer,
  PerspectiveCamera,
  Scene,
  PointLight,
  PointLightHelper,
  GridHelper,
  PolarGridHelper,
  Group,
  BoxHelper,
  WireframeGeometry,
  LineSegments,
  BoxHelper,
  EdgesGeometry,
  LineSegments,
  BoxHelper,
  BoxHelper,
  BoxHelper,
  Vector3,
  Euler,
  Quaternion,
  Vector3,
  BufferGeometryLoader,
  MeshNormalMaterial,
  Matrix4,
  InstancedMesh,
  Matrix4,
  Mesh,
  Matrix4,
  Mesh,
  PerspectiveCamera,
  WebGLRenderer,
  sRGBEncoding,
  Scene,
  Color,
  PerspectiveCamera,
  Scene,
  Color,
  Fog,
  AmbientLight,
  DirectionalLight,
  DirectionalLight,
  BufferGeometry,
  Color,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  Vector3,
  BufferAttribute,
  BufferAttribute,
  BufferAttribute,
  MeshPhongMaterial,
  DoubleSide,
  Mesh,
  Raycaster,
  Vector2,
  BufferGeometry,
  BufferAttribute,
  LineBasicMaterial,
  Line,
  WebGLRenderer,
  Vector2,
  PerspectiveCamera,
  Scene,
  Color,
  DirectionalLight,
  BoxGeometry,
  Mesh,
  MeshLambertMaterial,
  Raycaster,
  WebGLRenderer,
  MathUtils,
  MathUtils,
  MathUtils,
  Vector2,
  Vector3,
  PerspectiveCamera,
  Scene,
  Color,
  Scene,
  WebGLRenderTarget,
  AmbientLight,
  SpotLight,
  MeshBasicMaterial,
  MeshPhongMaterial,
  Float32BufferAttribute,
  Matrix4,
  Quaternion,
  Color,
  BoxGeometry,
  Vector3,
  Euler,
  Vector3,
  Mesh,
  Mesh,
  Mesh,
  BoxGeometry,
  MeshLambertMaterial,
  WebGLRenderer,
  Vector2,
  OrthographicCamera,
  Scene,
  Color,
  DirectionalLight,
  BoxGeometry,
  Mesh,
  MeshLambertMaterial,
  Raycaster,
  WebGLRenderer,
  MathUtils,
  MathUtils,
  MathUtils,
  Vector2,
  PerspectiveCamera,
  Scene,
  Color,
  SphereGeometry,
  MeshBasicMaterial,
  Mesh,
  BufferGeometry,
  Vector3,
  Vector3,
  Float32BufferAttribute,
  Object3D,
  LineBasicMaterial,
  Line,
  LineSegments,
  Raycaster,
  WebGLRenderer,
  MathUtils,
  MathUtils,
  MathUtils,
  Scene,
  PerspectiveCamera,
  BoxGeometry,
  Color,
  BufferGeometry,
  Float32BufferAttribute,
  Float32BufferAttribute,
  ShaderMaterial,
  Color,
  TextureLoader,
  Points,
  WebGLRenderer,
  Raycaster,
  Vector2,
  Vector2,
  Matrix4,
  BufferGeometry,
  BufferAttribute,
  BufferAttribute,
  PointsMaterial,
  Points,
  BufferAttribute,
  PointsMaterial,
  Points,
  BufferAttribute,
  PointsMaterial,
  Points,
  Scene,
  Clock,
  PerspectiveCamera,
  Color,
  Color,
  Color,
  SphereGeometry,
  MeshBasicMaterial,
  Mesh,
  WebGLRenderer,
  Raycaster,
} from "three";

import Stats from "three/examples/jsm/libs/stats.module.js";

let renderer, scene, camera, stats;
let pointclouds;
let raycaster;
let intersection = null;
let spheresIndex = 0;
let clock;
let toggle = 0;

const pointer = new Vector2();
const spheres = [];

const threshold = 0.1;
const pointSize = 0.05;
const width = 80;
const length = 160;
const rotateY = new Matrix4().makeRotationY(0.005);

init();
animate();

function generatePointCloudGeometry(color, width, length) {
  const geometry = new BufferGeometry();
  const numPoints = width * length;

  const positions = new Float32Array(numPoints * 3);
  const colors = new Float32Array(numPoints * 3);

  let k = 0;

  for (let i = 0; i < width; i++) {
    for (let j = 0; j < length; j++) {
      const u = i / width;
      const v = j / length;
      const x = u - 0.5;
      const y = (Math.cos(u * Math.PI * 4) + Math.sin(v * Math.PI * 8)) / 20;
      const z = v - 0.5;

      positions[3 * k] = x;
      positions[3 * k + 1] = y;
      positions[3 * k + 2] = z;

      const intensity = (y + 0.1) * 5;
      colors[3 * k] = color.r * intensity;
      colors[3 * k + 1] = color.g * intensity;
      colors[3 * k + 2] = color.b * intensity;

      k++;
    }
  }

  geometry.setAttribute("position", new BufferAttribute(positions, 3));
  geometry.setAttribute("color", new BufferAttribute(colors, 3));
  geometry.computeBoundingBox();

  return geometry;
}

function generatePointcloud(color, width, length) {
  const geometry = generatePointCloudGeometry(color, width, length);
  const material = new PointsMaterial({ size: pointSize, vertexColors: true });

  return new Points(geometry, material);
}

function generateIndexedPointcloud(color, width, length) {
  const geometry = generatePointCloudGeometry(color, width, length);
  const numPoints = width * length;
  const indices = new Uint16Array(numPoints);

  let k = 0;

  for (let i = 0; i < width; i++) {
    for (let j = 0; j < length; j++) {
      indices[k] = k;
      k++;
    }
  }

  geometry.setIndex(new BufferAttribute(indices, 1));

  const material = new PointsMaterial({ size: pointSize, vertexColors: true });

  return new Points(geometry, material);
}

function generateIndexedWithOffsetPointcloud(color, width, length) {
  const geometry = generatePointCloudGeometry(color, width, length);
  const numPoints = width * length;
  const indices = new Uint16Array(numPoints);

  let k = 0;

  for (let i = 0; i < width; i++) {
    for (let j = 0; j < length; j++) {
      indices[k] = k;
      k++;
    }
  }

  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.addGroup(0, indices.length);

  const material = new PointsMaterial({ size: pointSize, vertexColors: true });

  return new Points(geometry, material);
}

function init() {
  const container = document.getElementById("container");

  scene = new Scene();

  clock = new Clock();

  camera = new PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    1,
    10000
  );
  camera.position.set(10, 10, 10);
  camera.lookAt(scene.position);
  camera.updateMatrix();

  //

  const pcBuffer = generatePointcloud(new Color(1, 0, 0), width, length);
  pcBuffer.scale.set(5, 10, 10);
  pcBuffer.position.set(-5, 0, 0);
  scene.add(pcBuffer);

  const pcIndexed = generateIndexedPointcloud(
    new Color(0, 1, 0),
    width,
    length
  );
  pcIndexed.scale.set(5, 10, 10);
  pcIndexed.position.set(0, 0, 0);
  scene.add(pcIndexed);

  const pcIndexedOffset = generateIndexedWithOffsetPointcloud(
    new Color(0, 1, 1),
    width,
    length
  );
  pcIndexedOffset.scale.set(5, 10, 10);
  pcIndexedOffset.position.set(5, 0, 0);
  scene.add(pcIndexedOffset);

  pointclouds = [pcBuffer, pcIndexed, pcIndexedOffset];

  //

  const sphereGeometry = new SphereGeometry(0.1, 32, 32);
  const sphereMaterial = new MeshBasicMaterial({ color: 0xff0000 });

  for (let i = 0; i < 40; i++) {
    const sphere = new Mesh(sphereGeometry, sphereMaterial);
    scene.add(sphere);
    spheres.push(sphere);
  }

  //

  renderer = new WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  //

  raycaster = new Raycaster();
  raycaster.params.Points.threshold = threshold;

  //

  stats = new Stats();
  container.appendChild(stats.dom);

  //

  window.addEventListener("resize", onWindowResize);
  document.addEventListener("pointermove", onPointerMove);
}

function onPointerMove(event) {
  pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
  pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);

  render();
  stats.update();
}

function render() {
  camera.applyMatrix4(rotateY);
  camera.updateMatrixWorld();

  raycaster.setFromCamera(pointer, camera);

  const intersections = raycaster.intersectObjects(pointclouds);
  intersection = intersections.length > 0 ? intersections[0] : null;

  if (toggle > 0.02 && intersection !== null) {
    spheres[spheresIndex].position.copy(intersection.point);
    spheres[spheresIndex].scale.set(1, 1, 1);
    spheresIndex = (spheresIndex + 1) % spheres.length;

    toggle = 0;
  }

  for (let i = 0; i < spheres.length; i++) {
    const sphere = spheres[i];
    sphere.scale.multiplyScalar(0.98);
    sphere.scale.clampScalar(0.01, 1);
  }

  toggle += clock.getDelta();

  renderer.render(scene, camera);
}
